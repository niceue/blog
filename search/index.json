[{"content":"回顾开博客历程 2010年，开始在 VPS 上用 emlog 搭建个人博客，对未来充满着期待。 2013年，切换到 Typecho，原生支持 Markdown 排版语法，坚信“念念不忘，必有回响”。 2023年，回头一看：10年了文章没写多少，只有 Linode VPS “念念不忘，每月扣钱”。 正所谓 也就写写 Markdown，折腾未必有回响。\n与其维护服务器，不如加入羊毛党。\n赞美一下，Hugo 和 Github Pages 真香！\nFor more information about this theme, check the documentation: https://stack.jimmycai.com/\nPhoto by Pawel Czerwinski on Unsplash\n","date":"2023-09-15T00:00:00Z","image":"https://blog.niceue.com/p/the-new-blog/cover_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.niceue.com/p/the-new-blog/","title":"The New Blog"},{"content":"背景 需要多台电脑访问同一个本地的 redis 服务。打算在连接网线的固定IP的电脑上来安装 Redis，这台电脑是 Windows 10 系统，而 Redis 官方没有直接支持在 Windows 下安装运行。\n下面是 Redis 官方原话：\nUse Redis on Windows for development Redis is not officially supported on Windows. However, you can install Redis on Windows for development by the following the instructions below.\nTo install Redis on Windows, you\u0026rsquo;ll first need to enable WSL2 (Windows Subsystem for Linux). WSL2 lets you run Linux binaries natively on Windows. For this method to work, you\u0026rsquo;ll need to be running Windows 10 version 2004 and higher or Windows 11.\n所以官方推荐安装在 WSL2 子系统上。\n安装 WSL2 在 Windows 10 上安装 WSL2 很简单：\n打开 PowerShell(管理员) 运行命令 1 wsl --install 此命令将启用所需的可选组件，下载最新的 Linux 内核，将 WSL2 设置为默认值，并安装 Linux 发行版（默认安装 Ubuntu）。这个安装过程很快，期间会提示要重启一下电脑，电脑重启后会接着安装完成。\nWSL2 安装完成后，可以在 PowerShell 用 wsl 命令直接进入 Linux 子系统。\n安装和配置 Redis 安装 Redis： 1 2 3 4 5 6 curl -fsSL https://packages.redis.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg echo \u0026#34;deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb $(lsb_release -cs) main\u0026#34; | sudo tee /etc/apt/sources.list.d/redis.list sudo apt-get update sudo apt-get install redis 配置 Redis 支持局域网访问： 修改 /etc/redis/redis.conf，注释掉 bind 127.0.0.1，并将 protected-mode 改为 no\n1 2 3 # bind 127.0.0.1 protected-mode no 启动 Redis 1 sudo service redis-server start 从局域网访问 WSL2 网络 要实现从局域网访问 WSL2 网络，需要在 Windows 上配置 端口转发 和 防火墙允许入站规则。参考以下 PowerShell 命令（需以管理员权限执行）：\n1 2 3 4 5 6 7 8 9 # 查询 WSL2 IP 地址 PS C:\\Users\\jony\u0026gt; wsl -- hostname -I 172.19.42.138 # 配置端口转发：外网访问 windows 8080 端口转发到 172.19.42.138:8080 PS C:\\Users\\jony\u0026gt; netsh interface portproxy add v4tov4 listenport=6379 connectaddress=172.19.42.138 connectport=6379 # 添加允许入站规则 PS C:\\Users\\jony\u0026gt; New-NetFirewallRule -DisplayName \u0026#34;Allow Inbound TCP Port 6379\u0026#34; -Direction Inbound -Action Allow -Protocol TCP -LocalPort 6379 配置完后可在局域网用其他设备通过 Windows IP 访问 WSL2 服务。\n对应的删除配置命令：\n1 2 3 4 5 # 删除端口转发规则 C:\\Users\\jony\u0026gt; netsh interface portproxy delete v4tov4 listenport=6379 # 删除防火墙入站规则 C:\\Users\\jony\u0026gt; Remove-NetFirewallRule -DisplayName \u0026#34;Allow Inbound TCP Port 6379\u0026#34; 参考资料： Install Redis on Windows 使用 WSL 在 Windows 上安装 Linux Windows 10 WSL2 网络配置 ","date":"2022-07-28T14:52:00Z","image":"https://blog.niceue.com/p/installing-redis-on-windows-wsl2-and-setting-up-lan-access/cover_hu0b6d6eb651897541122c4265399f93d0_47876_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.niceue.com/p/installing-redis-on-windows-wsl2-and-setting-up-lan-access/","title":"在 Windows WSL2 环境安装 Redis 并设置局域网访问"},{"content":"Node.js 原生模块是用 C++ 编写的 Node.js 扩展。C++ 源码通过 node-gyp 编译为 .node 后缀的二进制文件（类似于 .dll 和 .so）。在 Node.js 环境中可以直接用 require() 函数将 .node 文件初始化为动态链接库。一些 npm 包会包含 C++ 扩展，例如： node-ffi、node-iconv、node-usb，但都是源码版本，在安装后需要编译后才能被 Node.js 调用。\nElectron 同样也支持 Node 原生模块，但由于和官方的 Node 相比使用了不同的 V8 引擎，如果你想编译原生模块，则需要手动设置 Electron 的 headers 的位置。\n环境准备 不管是 Node.js 环境或是 Electron 中使用原生模块，都需要准备一个编译工具 node-gyp。我们这里使用的是 windows 环境开发，参考 node-gyp 的安装说明还需要安装 windows-build-tools。\n用管理员权限打开 CMD 或 PowerShell 窗口，运行以下命令：\n1 2 npm i -g node-gyp npm i -g --production windows-build-tools windows-build-tools 安装时间可能会长一点，要耐心等待。\n项目配置 在安装 npm 模块之前还要设置一些环境变量，建议在项目目录下放一个 .npmrc 文件，内容如下：\n1 2 3 4 5 6 7 8 9 10 registry=https://registry.npm.taobao.org NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node ELECTRON_MIRROR=https://npm.taobao.org/mirrors/electron arch=ia32 target_arch=ia32 msvs_version=2015 disturl=https://atom.io/download/electron runtime=electron target=1.8.4 build_from_source=true 参数说明：\nregistry - 配置 npm 包镜像 NODEJS_ORG_MIRROR - 配置 Node.js 头文件下载镜像 ELECTRON_MIRROR - Electron 下载镜像 disturl - Electron 头文件镜像（用了 electron-rebuild 模块才需要） arch、target_arch - 根据目标环境定义为 ia32 或 x64 编译 通过以上配置不需要 electron-rebuild ，直接用 npm 或 yarn 安装新原生包的时候，会自动编译为适用当前 electron 版本的原生模块到 {module_name}/build/Release/xxx.node。由于这个构建后的路径是动态的，node-ffi 等第三方模块会使用 bindings 去动态找到这个 .node 文件。bindings 的原理是，首先定位到当前包的目录，然后通过预设一些搜寻路径，一个个尝试读取，直到找到为止。\n项目构建 问题：找不到 .node 文件 bindings 的搜寻方式在 js 源码未压缩的情况下当然没问题，但我们的项目中通常还使用了 webpack。 在开发模式下能够找到 node_modules 下的文件也没有问题，构建到生产环境后就没有 node_modules 了，而且 webpack 也不支持打包动态路径的文件。我想到两种解决方案：\n方案一、将 node-ffi 拷贝一份修改 bindings 为写死路径，当然每个用到 bindings 的包都要修改。\n1 2 3 4 // ffi 下的 bindings.js module.exports = require(\u0026#39;bindings\u0026#39;)(\u0026#39;ffi_bindings.node\u0026#39;) // 改为 module.exports = require(\u0026#39;../build/Release/ffi_bindings.node\u0026#39;) 方案二、自己实现一个 bindings 映射，并利用 webpack 的 alias 功能替换 bindings 模块。\n增加 bindings.js 1 2 3 4 5 6 7 8 9 10 function bindings (name) { if (name === \u0026#39;ffi_bindings.node\u0026#39;) { return require(\u0026#39;ffi/build/Release/ffi_bindings.node\u0026#39;) } if (name === \u0026#39;binding\u0026#39;) { return require(\u0026#39;ref/build/Release/binding.node\u0026#39;) } } module.exports = bindings 配置 webpack 别名 1 2 3 4 5 6 7 8 9 10 11 // webpack.main.config.js module.exports = { ..., resolve: { extensions: [\u0026#39;.js\u0026#39;, \u0026#39;.json\u0026#39;, \u0026#39;.node\u0026#39;], alias: { // 如果用 bindings 包，就会找不到 .node 模块，这里替换成自己的实现 \u0026#39;bindings\u0026#39;: path.resolve(__dirname, \u0026#39;../addons/bindings.js\u0026#39;) } }, ... 显然方案二更好一点，只需要自己实现一个 bindings.js，而不用去动第三方包的源码，所以我们直接用了方案二。\n问题：打包 asar 后，提取出 .node 文件 Electron 官方文档应用程序打包有说明，二进制文件不要在 asar 中执行，需要 unpack 出来。我们用了 electron-packager 可以通过 asar 参数配置：\n1 2 3 asar: { unpack: \u0026#39;*.node\u0026#39; } 这样，会把 .node 文件都提取到 app.asar.unpacked 目录。但是它只负责提取并不会自动更新 .node 文件的访问地址到新的路径。所以我想到了用 webpack 的 file-loader：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // webpack.main.config.js module: { rules: [ { test: /\\.node$/, loader: \u0026#39;file-loader\u0026#39;, options: { name: \u0026#39;[name].[ext]\u0026#39;, outputPath: \u0026#39;addons\u0026#39;, publicPath: \u0026#39;../../app.asar.unpacked/addons\u0026#39; } } ] } 我 app 打包后的项目结构是这样的\n1 2 3 4 5 app.asar.unpacked app ---main ---renderer ---package.json JS 是在 main 目录的主线程里面访问原生模块的，打包出来的路径也是这样。所以相对路径是要向上两级找到 app.asar.unpacked 目录。\n运行一下 npm run build 打包。\n文件按我预期那样生成好了!\n好的，运行一下程序：\nTypeError: Cannot read property \u0026lsquo;int64\u0026rsquo; of undefined\n程序跑不起来了！\nbindings 也是直接 require(\u0026lsquo;addon.node\u0026rsquo;) 呀，Node.js 官网也是这样说的。怎么构建后就不行了呢？\n后面，我在webpack 的 loader 中找到 node-loader，里面说明\n在 enhanced-require 中执行 node add-ons 所以，node-loader 是针对魔改过的 require（非 node 环境 require）的。这有可能是在 Electron 或是 webpack 发生的。\n于是我对.node文件增加一个node-loader\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 module: { rules: [ { test: /\\.node$/, use: [ \u0026#39;node-loader\u0026#39;, { loader: \u0026#39;file-loader\u0026#39;, options: { name: \u0026#39;[name].[ext]\u0026#39;, outputPath: \u0026#39;addons\u0026#39;, publicPath: \u0026#39;../../app.asar.unpacked/addons\u0026#39; } } ] } ] } 然后重新构建。一切问题都解决了！\n相关资料：\nhttps://electronjs.org/docs/tutorial/using-native-node-modules\nhttps://nodejs.org/dist/latest/docs/api/addons.html\nhttps://github.com/nodejs/node-gyp/\nhttps://doc.webpack-china.org/loaders/node-loader/\n","date":"2018-03-28T16:43:00Z","image":"https://blog.niceue.com/img/electron.webp","permalink":"https://blog.niceue.com/p/using-node.js-native-modules-in-electron/","title":"在 Electron 使用 Node.js 原生模块"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /********** * reset *********/ * {box-sizing: border-box; -webkit-tap-highlight-color: rgba(0,0,0,0);} body, dl, dt, dd, ul, ol, li, h1, h2, h3, h4, h5, h6, pre, code, form, fieldset, legend, input, textarea, p, blockquote, th, td, hr, button, article, aside, details, figcaption, figure, footer, header, menu, nav, section { margin: 0; padding: 0; border: 0; } /* 默认不要下划线 */ a {text-decoration: none;} /* 按钮文本不可选 */ button {user-select: none;} img {vertical-align: middle;} /* 加载不出来的图片不要显示灰色边框 */ img:not([src]),img[src=\u0026#34;\u0026#34;] {opacity: 0;} ul, ol {list-style: none;} table {border-collapse: collapse; border-spacing: 0;} input, select, button, textarea {font-size: 100%; font: inherit;} html, body {height: 100%; overflow-x: hidden;} ","date":"2017-11-24T22:12:00Z","image":"https://blog.niceue.com/img/code.jpg","permalink":"https://blog.niceue.com/p/style-reset-for-mobile/","title":"适用移动端的样式重置"},{"content":"\n","date":"2017-10-28T14:20:00Z","image":"https://blog.niceue.com/img/python.jpg","permalink":"https://blog.niceue.com/p/see-results-in-three-months/","title":"三个月后看成果"},{"content":"情景演示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Someone(object): def __init__(self): self.speak = \u0026#39;haha\u0026#39; def __getattr__(self, name): if not name[0].isupper(): return object.__getattribute__(self, name) def __getattr(cls, name): return object.__getattribute__(self, name) try: cls = eval(name) except: print(\u0026#39;No %s\u0026#39; % name) raise NotImplementedError cls.__getattr__ = __getattr instance = cls() setattr(self, name, instance) return instance class Tom(object): def run(self): return \u0026#39;running Tom\u0026#39; class Jerry(object): def run(self): return \u0026#39;running Jerry\u0026#39; men = Someone() print(men.speak) print(men.Tom.run()) print(men.Jerry.run()) # haha # running Tom # running Jerry 子类 TOM 和 Jerry 并没有显式继承 Speaker，而且实例化的是父类 Speaker，调用子类名称空间的时候自动实例化。\n实际应用时，上面的类可能不在同一个文件中，这时候可以通过动态加载类或包来实现\nsomeone.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # -*- coding: utf-8 -*- import importlib class Action(object): _pkg_base = \u0026#39;some/path/\u0026#39; def __getattr__(self, name): pkg = _pkg_base + name try: module = importlib.import_module(pkg) Action = module.Action except ImportError: Action = object def __getattr(cls, name): return object.__getattribute__(cls._myself, name) Action.__getattr__ = __getattr instance = Action() instance._myself = self setattr(self, name, instance) return instance tom.py\n1 2 3 class Action(object): def run(self): return \u0026#39;running Tom\u0026#39; jerry.py\n1 2 3 class Action(object): def run(self): return \u0026#39;running Jerry\u0026#39; ","date":"2017-01-16T00:00:00Z","image":"https://blog.niceue.com/img/python.jpg","permalink":"https://blog.niceue.com/p/implementing-the-autofactory-pattern-in-python/","title":"Python 实现自动工厂模式"},{"content":"源码编译方式安装 1 2 3 4 5 6 wget https://www.python.org/ftp/python/3.5.3/Python-3.5.3.tar.xz tar xvf Python-3.5.3.tar.xz cd Python-3.5.3 ./configure make make install 在某些系统环境下make \u0026amp; make install 会报错，分开执行才能安装成功 源码编译安装好后，自带 python3 和 pip3\n文件头格式 1 2 #!/usr/bin/env python3 # -*- coding: utf-8 -*- 如果不是需要执行的入口文件，第一行也可以不要\n","date":"2017-01-10T00:00:00Z","image":"https://blog.niceue.com/img/python.jpg","permalink":"https://blog.niceue.com/p/installing-python3-on-linux/","title":"在 Linux 上安装 Python3"},{"content":"方式一：yum 安装 1 2 3 # 其中 setup_7.x 中的 7.x 为要安装的版本 wget -qO- https://rpm.nodesource.com/setup_7.x | bash - yum install -y nodejs 方式二：编译安装 1 2 3 4 5 wget https://npm.taobao.org/mirrors/node/latest/node-v7.4.0-linux-x64.tar.xz tar xvf node-v7.4.0-linux-x64.tar.xz cd node-v7.4.0-linux-x64.tar.xz ./configure make \u0026amp;\u0026amp; make install ","date":"2017-01-05T00:00:00Z","image":"https://blog.niceue.com/img/nodejs.png","permalink":"https://blog.niceue.com/p/installing-nodejs-on-linux/","title":"在 Linux 上安装 Node.js"},{"content":" 出于优化的考虑，要么就有这个图标，要么就禁止产生这个请求。\n在页面的 head 区域，加上如下代码实现屏蔽：\n1 \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;data:;base64,=\u0026#34;\u0026gt; 或者详细一点\n1 \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;data:image/ico;base64,aWNv\u0026#34;\u0026gt; ","date":"2016-11-23T00:00:00Z","image":"https://blog.niceue.com/img/stop.jpg","permalink":"https://blog.niceue.com/p/blocking-requests-for-the-favicon-icon/","title":"阻止请求 favicon.ico 图标"},{"content":"Node.js 自带强大的加密功能 Crypto，它是基于 OpenSSL 库实现的加密技术。 DES 是一种对称加密算法，密匙长度必须是8的整数倍，在一些简单的应用场景经常被使用。\n为了网络上信息传输的安全（防止第三方窃取信息看到明文），发送发和接收方分别进行加密和解密，这样信息在网络上传输的时候就是相对安全的。\nDES 加密模式有： Electronic Codebook (ECB) , Cipher Block Chaining (CBC) , Cipher Feedback (CFB) , Output Feedback (OFB)。这里以密文分组链接模式 CBC 为例，使用了相同的 key 和 iv (Initialization Vector)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const crypto = require(\u0026#39;crypto\u0026#39;) // DES 加密 function desEncrypt (message, key) { key = key.length \u0026gt;= 8 ? key.slice(0, 8) : key.concat(\u0026#39;0\u0026#39;.repeat(8 - key.length)) const keyHex = new Buffer(key) const cipher = crypto.createCipheriv(\u0026#39;des-cbc\u0026#39;, keyHex, keyHex) let c = cipher.update(message, \u0026#39;utf8\u0026#39;, \u0026#39;base64\u0026#39;) c += cipher.final(\u0026#39;base64\u0026#39;) return c } // DES 解密 function desDecrypt (text, key) { key = key.length \u0026gt;= 8 ? key.slice(0, 8) : key.concat(\u0026#39;0\u0026#39;.repeat(8 - key.length)) const keyHex = new Buffer(key) const cipher = crypto.createDecipheriv(\u0026#39;des-cbc\u0026#39;, keyHex, keyHex) let c = cipher.update(text, \u0026#39;base64\u0026#39;, \u0026#39;utf8\u0026#39;) c += cipher.final(\u0026#39;utf8\u0026#39;) return c } 要查看 Node.js 支持哪些 Cipher,可以通过 crypto.getCiphers() 查看\n相关资料：\nhttps://nodejs.org/api/crypto.html\n","date":"2016-01-05T00:00:00Z","image":"https://blog.niceue.com/img/nodejs.png","permalink":"https://blog.niceue.com/p/des-encryption-and-decryption-in-nodejs/","title":"Node.js 中的 DES 加解密"},{"content":"国内 npm 镜像源： npmmirror 镜像源： https://registry.npmmirror.com 华为云镜像源：https://mirrors.huaweicloud.com/repository/npm/ 修改 npm 镜像源 方式一、命令行修改配置 1 2 3 4 # 配置 registry npm config set registry https://registry.npmmirror.com # 验证配置是否修改成功 npm config get registry 方式二、添加 .npmrc 配置文件 1 registry = https://registry.npmmirror.com .npmrc 按以下 4 级逐级查找，可以按需求选择配置的地方\n项目目录：/path/to/my/project/.npmrc 用户目录：~/.npmrc 全局配置：$PREFIX/etc/.npmrc 内置配置：/path/to/npm/.npmrc ","date":"2015-05-31T00:00:00Z","image":"https://blog.niceue.com/p/using-domestic-npm-mirrors/npm-cover_hu4c863a40fc80128992c98fa0ffeb7a27_438444_120x120_fill_box_smart1_3.png","permalink":"https://blog.niceue.com/p/using-domestic-npm-mirrors/","title":"使用国内 npm 镜像"},{"content":"记住密码带来安全隐患 当别人打开你的浏览器，就能直接登录进去。\n更进一步，若网站被 xss 攻击者利用，可以轻松获取到你的明文密码信息。攻击者只要构造一个包含用户名和密码的表单插入到 DOM，延时等待浏览器的自动填充，然后就可以获取到密码值。\n即使不被 xss 攻击，也可能被他人打开你的浏览器直接获取到明文密码。\n如何禁止表单自动填充 更改浏览器设置 作为个人用户可以考虑禁用这个选项，但作为网站还是得寻求其他方式，我们不能保证用户都更改设置。\n给表单设置 autocomplete=\u0026ldquo;off\u0026rdquo; 实践证明 autocomplete 这个属性可以关掉输入框获得焦点时的下拉选项，但不能禁用表单被自动填充。在 chrome 开发工具中可以看到，当 input 被自动填充后，会有一个 input:-webkit-autofill 的样式，但这个样式不可更改。而且也没有提供一个 autofill 的 DOM 接口来改变这个行为。\n有效的方式 用 Javascript 动态设置 password 的 type，来绕过浏览器的自动填充。经过实践，下面代码被证明有效果：\n1 2 3 4 5 const input = document.querySelector(\u0026#39;input[type=\u0026#34;password\u0026#34;]\u0026#39;); input.setAttribute(\u0026#39;type\u0026#39;, \u0026#39;text\u0026#39;); setTimeout(function() { input.setAttribute(\u0026#39;type\u0026#39;, \u0026#39;password\u0026#39;); }, 500); ","date":"2015-05-14T00:00:00Z","image":"https://blog.niceue.com/img/stop.jpg","permalink":"https://blog.niceue.com/p/disable-form-autofill/","title":"禁止密码表单被自动填充"},{"content":"在 Chrome，当选择了输入框的 autocomplete 值后，输入框会变成黄色背景。同时你会发现在 user agent 样式中有如下样式：\n1 2 3 4 5 input:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill { background-color: rgb(250, 255, 189); background-image: none; color: rgb(0, 0, 0); } 大多数童鞋都会采取覆盖这个默认样式的思路，甚至加 !important，结果都是无济于事。\n难道真的不能破？\n其实，在 stackoverflow 上早有人问这个问题了。比较靠谱的是采用内阴影强制覆盖背景：\n1 2 3 4 5 input:-webkit-autofill, input:-webkit-autofill:focus { box-shadow: 0 0 0 100px white inset; -webkit-text-fill-color: #333; } color 的设置同样不能覆盖，但是可以用 -webkit-text-fill-color 设定文字填充颜色的方式解决，所以上面的两行代码都是必须的，你可以根据自己的实际情况修改颜色值。还有需要注意的是，focus 的样式设置也是必须的。\n最后，其实还有更简单的办法，如果你不需要 autocomplete 功能，那么关掉就不会有这个烦恼了。\n1 \u0026lt;form autocomplete=\u0026#34;off\u0026#34;\u0026gt; ","date":"2014-10-25T00:00:00Z","image":"https://blog.niceue.com/p/remove-yellow-background-on-autofill-input-fields/cover_hu19b7e5eb37b7cba2c32660e43a92c300_12058_120x120_fill_q75_h2_box_smart1_2.webp","permalink":"https://blog.niceue.com/p/remove-yellow-background-on-autofill-input-fields/","title":"去除 Auto-filled 输入框上的黄色背景"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] One line code block 1 \u0026lt;p\u0026gt;A paragraph\u0026lt;/p\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2010-09-07T00:00:00Z","image":"https://blog.niceue.com/img/writing1.jpg","permalink":"https://blog.niceue.com/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"For more details, check out the documentation.\nBilibili video Tencent video YouTube video Generic video file Your browser doesn't support HTML5 video. Here is a link to the video instead. Gist GitLab Quote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Photo by Codioful on Unsplash\n","date":"2010-08-25T00:00:00Z","image":"https://blog.niceue.com/img/writing3.jpg","permalink":"https://blog.niceue.com/p/shortcodes/","title":"Shortcodes"}]